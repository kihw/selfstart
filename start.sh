#!/bin/bash

# Script de d√©marrage rapide pour SelfStart
# Ce script configure et d√©marre automatiquement SelfStart

set -e

# Couleurs pour les messages
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Fonction pour afficher des messages color√©s
print_message() {
    echo -e "${GREEN}[SelfStart]${NC} $1"
}

print_warning() {
    echo -e "${YELLOW}[SelfStart]${NC} $1"
}

print_error() {
    echo -e "${RED}[SelfStart]${NC} $1"
}

print_info() {
    echo -e "${BLUE}[SelfStart]${NC} $1"
}

# Fonction pour d√©tecter la commande Docker Compose disponible
detect_docker_compose() {
    if command -v docker-compose &> /dev/null; then
        echo "docker-compose"
    elif docker compose version &> /dev/null 2>&1; then
        echo "docker compose"
    else
        return 1
    fi
}

# Banner
echo -e "${BLUE}"
echo "  ____       _  __   ____  _             _   "
echo " / ___|  ___| |/ _| / ___|| |_ __ _ _ __| |_ "
echo " \___ \ / _ \ | |_  \___ \| __/ _\` | '__| __|"
echo "  ___) |  __/ |  _|  ___) | || (_| | |  | |_ "
echo " |____/ \___|_|_|   |____/ \__\__,_|_|   \__|"
echo -e "${NC}"
echo "Syst√®me de d√©marrage automatique de containers Docker"
echo "======================================================="
echo

# V√©rification des pr√©requis
print_info "V√©rification des pr√©requis..."

# V√©rifier Docker
if ! command -v docker &> /dev/null; then
    print_error "Docker n'est pas install√©. Veuillez installer Docker d'abord."
    exit 1
fi

# V√©rifier Docker Compose et d√©tecter la commande
if ! DOCKER_COMPOSE_CMD=$(detect_docker_compose); then
    print_error "Docker Compose n'est pas install√© ou n'est pas accessible."
    print_info "Pour installer Docker Compose:"
    print_info "  - Ubuntu/Debian: sudo apt-get install docker-compose-plugin"
    print_info "  - RHEL/CentOS: sudo yum install docker-compose-plugin"
    print_info "  - Ou suivez la documentation officielle Docker"
    exit 1
fi

print_message "‚úì Docker et Docker Compose sont disponibles (utilisation de: $DOCKER_COMPOSE_CMD)"

# V√©rifier que Docker fonctionne
if ! docker ps &> /dev/null; then
    print_error "Docker n'est pas d√©marr√© ou vous n'avez pas les permissions n√©cessaires."
    print_info "Essayez: sudo systemctl start docker"
    print_info "Ou ajoutez votre utilisateur au groupe docker: sudo usermod -aG docker \$USER"
    exit 1
fi

print_message "‚úì Docker fonctionne correctement"

# Configuration du fichier .env
if [ ! -f .env ]; then
    print_info "Cr√©ation du fichier de configuration .env..."
    
    # Demander le domaine
    echo -n "Entrez votre domaine (ou localhost pour les tests): "
    read -r domain
    domain=${domain:-localhost}
    
    # Cr√©er le fichier .env
    cp .env.example .env
    sed -i "s/BASE_DOMAIN=exemple.com/BASE_DOMAIN=$domain/" .env
    
    # G√©n√©rer une cl√© secr√®te
    if command -v openssl &> /dev/null; then
        secret_key=$(openssl rand -hex 32)
        sed -i "s/SECRET_KEY=votre_cle_secrete_ici/SECRET_KEY=$secret_key/" .env
    fi
    
    print_message "‚úì Fichier .env cr√©√© avec le domaine: $domain"
else
    print_message "‚úì Fichier .env existant d√©tect√©"
fi

# Cr√©er les r√©pertoires n√©cessaires
print_info "Cr√©ation des r√©pertoires de donn√©es..."
mkdir -p downloads media/tv media/movies media/music config data
# Permissions plus restrictives pour data
mkdir -p data
chmod -R 755 data
print_message "‚úì R√©pertoires cr√©√©s"

# Cr√©er le r√©pertoire pour les logs Caddy
print_info "Cr√©ation du r√©pertoire pour les logs Caddy..."
mkdir -p ./logs/caddy
print_message "‚úì R√©pertoire de logs cr√©√©"

# Cr√©er le r√©pertoire caddy et le Caddyfile si n√©cessaire
print_info "Configuration de Caddy..."
mkdir -p ./caddy
if [ ! -f ./caddy/Caddyfile ]; then
    # Cr√©er un Caddyfile de base
    cat > ./caddy/Caddyfile << 'EOF'
# Configuration Caddy pour SelfStart
# Reverse proxy intelligent avec d√©marrage automatique de containers

# Configuration globale
{
    # Configuration automatique HTTPS
    email admin@{$BASE_DOMAIN}
    
    # Optimisations de performance
    servers {
        protocols h1 h2 h3
    }
}

# Route principale - Exemple avec Sonarr
sonarr.{$BASE_DOMAIN} {
    # Matcher pour v√©rifier si le container est en cours d'ex√©cution
    @running `curl -sf http://backend-api:8000/api/status?name=sonarr | grep -o '"status":"running"'`
    
    # Si le container est en cours d'ex√©cution, rediriger vers lui
    handle @running {
        reverse_proxy sonarr:8989 {
            # Headers pour pr√©server l'IP client
            header_up Host {host}
            header_up X-Real-IP {remote_host}
            header_up X-Forwarded-For {remote_host}
            header_up X-Forwarded-Proto {scheme}
            
            # Timeout augment√© pour les applications lentes
            timeout 30s
        }
    }
    
    # Sinon, afficher l'interface de chargement
    handle {
        reverse_proxy frontend-loader:3000 {
            header_up X-Container-Name sonarr
            header_up X-Container-Port 8989
            header_up Host {host}
            header_up X-Real-IP {remote_host}
            header_up X-Forwarded-For {remote_host}
            header_up X-Forwarded-Proto {scheme}
        }
    }
    
    # Logs pour debugging
    log {
        output file /var/log/caddy/sonarr.log
        level INFO
    }
}

# Dashboard d'administration
admin.{$BASE_DOMAIN} {
    reverse_proxy frontend-dashboard:3000 {
        header_up Host {host}
        header_up X-Real-IP {remote_host}
        header_up X-Forwarded-For {remote_host}
        header_up X-Forwarded-Proto {scheme}
    }
    
    # Authentification basique (optionnelle)
    @auth_enabled {
        env ENABLE_BASIC_AUTH true
    }
    
    handle @auth_enabled {
        basicauth {
            {$ADMIN_USERNAME} {$ADMIN_PASSWORD_HASH}
        }
    }
    
    log {
        output file /var/log/caddy/admin.log
        level INFO
    }
}

# Configuration pour le d√©veloppement local (localhost)
localhost:8080 {
    # API backend accessible directement
    handle /api/* {
        reverse_proxy backend-api:8000
    }
    
    # Interface frontend
    handle {
        reverse_proxy frontend-loader:3000
    }
}

# API directe (pour d√©veloppement)
api.{$BASE_DOMAIN} {
    reverse_proxy backend-api:8000 {
        header_up Host {host}
        header_up X-Real-IP {remote_host}
        header_up X-Forwarded-For {remote_host}
        header_up X-Forwarded-Proto {scheme}
    }
    
    log {
        output file /var/log/caddy/api.log
        level INFO
    }
}

# Gestion des erreurs globales
handle_errors {
    @404 expression `{http.error.status_code} == 404`
    handle @404 {
        respond "Service non disponible - V√©rifiez la configuration SelfStart" 404
    }
    
    @500 expression `{http.error.status_code} >= 500`
    handle @500 {
        respond "Erreur serveur - Contactez l'administrateur" 500
    }
}
EOF
    print_message "‚úì Caddyfile cr√©√©"
else
    print_message "‚úì Caddyfile existant d√©tect√©"
fi

# Cr√©er le r√©seau Docker
print_info "Cr√©ation du r√©seau Docker..."
if ! docker network ls | grep -q selfstart-network; then
    docker network create selfstart-network
    print_message "‚úì R√©seau selfstart-network cr√©√©"
else
    print_message "‚úì R√©seau selfstart-network existe d√©j√†"
fi

# Arr√™ter les services existants
print_info "Arr√™t des services existants..."
$DOCKER_COMPOSE_CMD down 2>/dev/null || true

# Construire et d√©marrer les services
print_info "Construction et d√©marrage des services SelfStart..."
$DOCKER_COMPOSE_CMD up -d --build

# Attendre que les services soient pr√™ts
print_info "Attente du d√©marrage des services..."
sleep 10

# V√©rifier l'√©tat des services
print_info "V√©rification de l'√©tat des services..."

if $DOCKER_COMPOSE_CMD ps | grep -q "Up"; then
    print_message "‚úì Services SelfStart d√©marr√©s avec succ√®s!"
else
    print_error "Certains services ont √©chou√©. V√©rifiez les logs avec: $DOCKER_COMPOSE_CMD logs"
    exit 1
fi

# Rendre le script de test r√©seau ex√©cutable
print_info "Configuration du script de diagnostic r√©seau..."
chmod +x network-test.sh
print_message "‚úì Script network-test.sh pr√™t"

# Afficher les informations de connexion
echo
print_message "üéâ SelfStart est maintenant op√©rationnel!"
echo
print_info "URLs d'acc√®s:"

# Lire le domaine depuis .env
domain=$(grep "BASE_DOMAIN=" .env | cut -d'=' -f2)

if [ "$domain" = "localhost" ]; then
    echo "  Interface d'administration: http://localhost:8080"
    echo "  API Backend: http://localhost:8000"
    echo "  Frontend: http://localhost:3001"
    echo "  Dashboard: http://localhost:3002 (d√©marrer avec: make dashboard)"
else
    echo "  Interface d'administration: https://admin.$domain"
    echo "  API Backend: https://api.$domain"
    echo "  Exemples d'applications:"
    echo "    - Sonarr: https://sonarr.$domain"
    echo "    - Radarr: https://radarr.$domain"
    echo "    - Jellyfin: https://jellyfin.$domain"
fi

echo
print_info "Commandes utiles:"
echo "  Voir les logs:           $DOCKER_COMPOSE_CMD logs -f"
echo "  Arr√™ter les services:    $DOCKER_COMPOSE_CMD down"
echo "  Red√©marrer:              $DOCKER_COMPOSE_CMD restart"
echo "  Mettre √† jour:           git pull && $DOCKER_COMPOSE_CMD up -d --build"
echo "  Tester le r√©seau:        ./network-test.sh"

echo
print_info "Pour d√©marrer des applications d'exemple:"
echo "  $DOCKER_COMPOSE_CMD -f docker-compose.yml -f examples/docker-compose.apps.yml --profile apps up -d"

echo
print_info "Pour d√©marrer le dashboard d'administration:"
echo "  $DOCKER_COMPOSE_CMD --profile dashboard up -d"

echo
print_warning "Notes importantes:"
echo "  1. Pour la production, modifiez les mots de passe dans .env"
echo "  2. Configurez vos DNS pour pointer vers ce serveur"
echo "  3. Assurez-vous que les ports 80 et 443 sont ouverts"

echo
print_message "Installation termin√©e! Consultez le README.md pour plus d'informations."